/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * @zanin/api
 * OpenAPI spec version: 0.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { axios } from './lib/axios';
import type { ErrorType } from './lib/axios';
export type UserOrganizationsItem = {
  /** @nullable */
  updatedAt: string | null;
  createdAt: string;
  id: string;
  metadata: unknown;
  /** @nullable */
  logo: string | null;
  /** @nullable */
  slug: string | null;
  name: string;
};

export interface User {
  id: string;
  createdAt: string;
  updatedAt: string;
  email: string;
  emailVerified: boolean;
  name: string;
  image?: string;
  activeOrganizationId: string;
  organizations: UserOrganizationsItem[];
}

export interface EnrollmentResponse {
  success: boolean;
  audioDurationSeconds: number;
  embeddingDimension: number;
  message?: string;
}

/**
 * Profile information
 */
export interface ProfileInfo {
  exists: boolean;
  user_id: string;
  embedding_dimension?: number;
  created_at?: string;
}

export interface OwnerAnalysis {
  communicationStyle: string;
  strengths: string[];
  improvements: string[];
  conversationRole: string;
  keyBehaviors: string[];
  speakingPercentage: number;
  turnCount: number;
}

export type RecordingStatus = typeof RecordingStatus[keyof typeof RecordingStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecordingStatus = {
  pending: 'pending',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed',
} as const;

export type RecordingTranscriptItemSpeaker = string | 'ME';

export type RecordingTranscriptItem = {
  speakerNumber: number;
  wordCount: number;
  speaker: RecordingTranscriptItemSpeaker;
  content: string;
  start: number;
  end: number;
};

export type RecordingVadSegmentsItemSegements = {
  start: number;
  end: number;
};

export type RecordingVadSegmentsItem = {
  segements: RecordingVadSegmentsItemSegements;
};

export type RecordingSpeakerLabels = { [key: string]: unknown };

export type RecordingMetadataSpeakerIdentification = {
  ownerSpeakingSeconds: number;
  otherSpeakingSeconds: number;
};

/**
 */
export type RecordingMetadataLanguage = typeof RecordingMetadataLanguage[keyof typeof RecordingMetadataLanguage];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecordingMetadataLanguage = {
  en: 'en',
} as const;

export type RecordingMetadata = {
  speakerIdentification: RecordingMetadataSpeakerIdentification;
  /** */
  language: RecordingMetadataLanguage;
};

export interface Recording {
  id: string;
  status: RecordingStatus;
  createdAt: string;
  updatedAt: string;
  finishedAt?: string;
  processingError?: string;
  title?: string;
  rawAudioUrl: string;
  cleanedAudioUrl?: string;
  confidence?: number;
  originalDuration?: number;
  transcript: RecordingTranscriptItem[];
  vadSegments: RecordingVadSegmentsItem[];
  speakerLabels: RecordingSpeakerLabels;
  metadata: RecordingMetadata;
  summary?: string;
  ownerAnalysis?: OwnerAnalysis;
}

export interface RecordingListResponse {
  recordings: Recording[];
  count: number;
}

/**
 * A search result for a recording chunk
 */
export interface RecordingSearchResult {
  id: string;
  score: number;
  text: string;
  recordingId: string;
  chunkIndex?: number;
}

/**
 * A recording with its matching search results
 */
export interface RecordingWithMatches {
  recordingId: string;
  matches: RecordingSearchResult[];
  topScore: number;
}

export interface RecordingSearchResponse {
  results: RecordingWithMatches[];
  totalMatches: number;
}

/**
 * Source used to answer the question
 */
export interface AnswerSource {
  recordingId: string;
  text: string;
  score: number;
}

export interface RecordingAskResponse {
  answer: string;
  sources: AnswerSource[];
}

export interface ChatThread {
  id: string;
  /** @nullable */
  recordingId: string | null;
  /** @nullable */
  referenceId: string | null;
  /** @nullable */
  title: string | null;
  lastActivityAt: string;
  createdAt: string;
}

export interface GetOrCreateThreadResponse {
  thread: ChatThread;
}

export interface GetOrCreateThreadRequest {
  recordingId?: string;
}

/**
 * Construct a type with a set of properties K of type T
 */
export interface RecordStringUnknown {[key: string]: unknown}

export type ChatMessageRole = typeof ChatMessageRole[keyof typeof ChatMessageRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ChatMessageRole = {
  user: 'user',
  assistant: 'assistant',
} as const;

/**
 * @nullable
 */
export type ChatMessageMetadata = RecordStringUnknown | null;

export interface ChatMessage {
  id: string;
  threadId: string;
  role: ChatMessageRole;
  content: string;
  /** @nullable */
  metadata: ChatMessageMetadata;
  createdAt: string;
}

export interface GetMessagesResponse {
  messages: ChatMessage[];
  count: number;
}

export interface SendMessageResponse {
  userMessage: ChatMessage;
  assistantMessage: ChatMessage;
}

export interface SendMessageRequest {
  content: string;
}

export interface Assistant {
  assistant_id: string;
  graph_id: string;
  name: string;
  created_at: string;
  updated_at: string;
  metadata: RecordStringUnknown;
}

export interface RunAgentResponse {
  threadId: string;
  response: string;
}

export interface RunAgentRequest {
  assistantId: string;
  message: string;
  threadId?: string;
}

export type EnrollBody = {
  audio: Blob;
};

export type CreateRecordingBody = {
  audio: Blob;
};

export type ListRecordingsParams = {
limit?: number;
offset?: number;
search?: string;
startDate?: string;
endDate?: string;
sortBy?: ListRecordingsSortBy;
sortOrder?: ListRecordingsSortOrder;
};

export type ListRecordingsSortBy = typeof ListRecordingsSortBy[keyof typeof ListRecordingsSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListRecordingsSortBy = {
  date: 'date',
  duration: 'duration',
} as const;

export type ListRecordingsSortOrder = typeof ListRecordingsSortOrder[keyof typeof ListRecordingsSortOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListRecordingsSortOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type SearchRecordingsParams = {
query: string;
startDate?: string;
endDate?: string;
limit?: number;
rerank?: boolean;
};

export type AskRecordingsParams = {
query: string;
recordingId?: string;
startDate?: string;
endDate?: string;
maxSources?: number;
};

export type GetMessagesParams = {
limit?: number;
offset?: number;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Retrieves the details of the user calling the API.
 */
export const getMe = (
    
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      
      return axios<User>(
      {url: `/v1/users/me`, method: 'GET', signal
    },
      options);
    }
  



export const getGetMeQueryKey = () => {
    return [
    `/v1/users/me`
    ] as const;
    }

    
export const getGetMeQueryOptions = <TData = Awaited<ReturnType<typeof getMe>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, request?: SecondParameter<typeof axios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({ signal }) => getMe(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMeQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>
export type GetMeQueryError = ErrorType<void>


export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Enroll a voice profile for the current user.
Upload an audio file containing your voice to create or update your voice profile.
 */
export const enroll = (
    enrollBody: EnrollBody,
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`audio`, enrollBody.audio)

      return axios<EnrollmentResponse>(
      {url: `/v1/sid/enroll`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getEnrollMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enroll>>, TError,{data: EnrollBody}, TContext>, request?: SecondParameter<typeof axios>}
): UseMutationOptions<Awaited<ReturnType<typeof enroll>>, TError,{data: EnrollBody}, TContext> => {

const mutationKey = ['enroll'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof enroll>>, {data: EnrollBody}> = (props) => {
          const {data} = props ?? {};

          return  enroll(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EnrollMutationResult = NonNullable<Awaited<ReturnType<typeof enroll>>>
    export type EnrollMutationBody = EnrollBody
    export type EnrollMutationError = ErrorType<void>

    export const useEnroll = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enroll>>, TError,{data: EnrollBody}, TContext>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof enroll>>,
        TError,
        {data: EnrollBody},
        TContext
      > => {

      const mutationOptions = getEnrollMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get the voice profile status for the current user.
 */
export const getProfile = (
    
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      
      return axios<ProfileInfo>(
      {url: `/v1/sid/profile`, method: 'GET', signal
    },
      options);
    }
  



export const getGetProfileQueryKey = () => {
    return [
    `/v1/sid/profile`
    ] as const;
    }

    
export const getGetProfileQueryOptions = <TData = Awaited<ReturnType<typeof getProfile>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>, request?: SecondParameter<typeof axios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProfileQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfile>>> = ({ signal }) => getProfile(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getProfile>>>
export type GetProfileQueryError = ErrorType<void>


export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          Awaited<ReturnType<typeof getProfile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProfile>>,
          TError,
          Awaited<ReturnType<typeof getProfile>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetProfile<TData = Awaited<ReturnType<typeof getProfile>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProfileQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete the voice profile for the current user.
 */
export const deleteProfile = (
    
 options?: SecondParameter<typeof axios>,) => {
      
      
      return axios<void>(
      {url: `/v1/sid/profile`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteProfileMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProfile>>, TError,void, TContext>, request?: SecondParameter<typeof axios>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProfile>>, TError,void, TContext> => {

const mutationKey = ['deleteProfile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProfile>>, void> = () => {
          

          return  deleteProfile(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProfileMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProfile>>>
    
    export type DeleteProfileMutationError = ErrorType<void>

    export const useDeleteProfile = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProfile>>, TError,void, TContext>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteProfile>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDeleteProfileMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Upload an audio file and create a new recording.
The audio will be processed asynchronously for transcription and speaker identification.
 */
export const createRecording = (
    createRecordingBody: CreateRecordingBody,
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`audio`, createRecordingBody.audio)

      return axios<Recording>(
      {url: `/v1/recordings`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getCreateRecordingMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRecording>>, TError,{data: CreateRecordingBody}, TContext>, request?: SecondParameter<typeof axios>}
): UseMutationOptions<Awaited<ReturnType<typeof createRecording>>, TError,{data: CreateRecordingBody}, TContext> => {

const mutationKey = ['createRecording'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRecording>>, {data: CreateRecordingBody}> = (props) => {
          const {data} = props ?? {};

          return  createRecording(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRecordingMutationResult = NonNullable<Awaited<ReturnType<typeof createRecording>>>
    export type CreateRecordingMutationBody = CreateRecordingBody
    export type CreateRecordingMutationError = ErrorType<void>

    export const useCreateRecording = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRecording>>, TError,{data: CreateRecordingBody}, TContext>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createRecording>>,
        TError,
        {data: CreateRecordingBody},
        TContext
      > => {

      const mutationOptions = getCreateRecordingMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List all recordings for the current organization.
Supports filtering by search term, date range, and sorting.
 */
export const listRecordings = (
    params?: ListRecordingsParams,
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      
      return axios<RecordingListResponse>(
      {url: `/v1/recordings`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListRecordingsQueryKey = (params?: ListRecordingsParams,) => {
    return [
    `/v1/recordings`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListRecordingsQueryOptions = <TData = Awaited<ReturnType<typeof listRecordings>>, TError = ErrorType<void>>(params?: ListRecordingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRecordings>>, TError, TData>>, request?: SecondParameter<typeof axios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListRecordingsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listRecordings>>> = ({ signal }) => listRecordings(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listRecordings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListRecordingsQueryResult = NonNullable<Awaited<ReturnType<typeof listRecordings>>>
export type ListRecordingsQueryError = ErrorType<void>


export function useListRecordings<TData = Awaited<ReturnType<typeof listRecordings>>, TError = ErrorType<void>>(
 params: undefined |  ListRecordingsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRecordings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRecordings>>,
          TError,
          Awaited<ReturnType<typeof listRecordings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListRecordings<TData = Awaited<ReturnType<typeof listRecordings>>, TError = ErrorType<void>>(
 params?: ListRecordingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRecordings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRecordings>>,
          TError,
          Awaited<ReturnType<typeof listRecordings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListRecordings<TData = Awaited<ReturnType<typeof listRecordings>>, TError = ErrorType<void>>(
 params?: ListRecordingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRecordings>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListRecordings<TData = Awaited<ReturnType<typeof listRecordings>>, TError = ErrorType<void>>(
 params?: ListRecordingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRecordings>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListRecordingsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Search recordings by semantic query.
Returns recordings with matching transcript chunks, ranked by relevance.
Optionally filter by date range using startDate and endDate (ISO 8601 format).
 */
export const searchRecordings = (
    params: SearchRecordingsParams,
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      
      return axios<RecordingSearchResponse>(
      {url: `/v1/recordings/search`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getSearchRecordingsQueryKey = (params?: SearchRecordingsParams,) => {
    return [
    `/v1/recordings/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSearchRecordingsQueryOptions = <TData = Awaited<ReturnType<typeof searchRecordings>>, TError = ErrorType<void>>(params: SearchRecordingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchRecordings>>, TError, TData>>, request?: SecondParameter<typeof axios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchRecordingsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchRecordings>>> = ({ signal }) => searchRecordings(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchRecordings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchRecordingsQueryResult = NonNullable<Awaited<ReturnType<typeof searchRecordings>>>
export type SearchRecordingsQueryError = ErrorType<void>


export function useSearchRecordings<TData = Awaited<ReturnType<typeof searchRecordings>>, TError = ErrorType<void>>(
 params: SearchRecordingsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchRecordings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchRecordings>>,
          TError,
          Awaited<ReturnType<typeof searchRecordings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchRecordings<TData = Awaited<ReturnType<typeof searchRecordings>>, TError = ErrorType<void>>(
 params: SearchRecordingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchRecordings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchRecordings>>,
          TError,
          Awaited<ReturnType<typeof searchRecordings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchRecordings<TData = Awaited<ReturnType<typeof searchRecordings>>, TError = ErrorType<void>>(
 params: SearchRecordingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchRecordings>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useSearchRecordings<TData = Awaited<ReturnType<typeof searchRecordings>>, TError = ErrorType<void>>(
 params: SearchRecordingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchRecordings>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchRecordingsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Ask a question and get an AI-generated answer based on your recordings.
Uses semantic search to find relevant transcript chunks and generates a response.
Optionally filter by date range using startDate and endDate (ISO 8601 format).
Optionally filter by a specific recording using recordingId.
 */
export const askRecordings = (
    params: AskRecordingsParams,
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      
      return axios<RecordingAskResponse>(
      {url: `/v1/recordings/ask`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getAskRecordingsQueryKey = (params?: AskRecordingsParams,) => {
    return [
    `/v1/recordings/ask`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getAskRecordingsQueryOptions = <TData = Awaited<ReturnType<typeof askRecordings>>, TError = ErrorType<void>>(params: AskRecordingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof askRecordings>>, TError, TData>>, request?: SecondParameter<typeof axios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAskRecordingsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof askRecordings>>> = ({ signal }) => askRecordings(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof askRecordings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AskRecordingsQueryResult = NonNullable<Awaited<ReturnType<typeof askRecordings>>>
export type AskRecordingsQueryError = ErrorType<void>


export function useAskRecordings<TData = Awaited<ReturnType<typeof askRecordings>>, TError = ErrorType<void>>(
 params: AskRecordingsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof askRecordings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof askRecordings>>,
          TError,
          Awaited<ReturnType<typeof askRecordings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAskRecordings<TData = Awaited<ReturnType<typeof askRecordings>>, TError = ErrorType<void>>(
 params: AskRecordingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof askRecordings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof askRecordings>>,
          TError,
          Awaited<ReturnType<typeof askRecordings>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAskRecordings<TData = Awaited<ReturnType<typeof askRecordings>>, TError = ErrorType<void>>(
 params: AskRecordingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof askRecordings>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAskRecordings<TData = Awaited<ReturnType<typeof askRecordings>>, TError = ErrorType<void>>(
 params: AskRecordingsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof askRecordings>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAskRecordingsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get a specific recording by ID.
 */
export const getRecording = (
    recordingId: string,
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      
      return axios<Recording>(
      {url: `/v1/recordings/${recordingId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetRecordingQueryKey = (recordingId?: string,) => {
    return [
    `/v1/recordings/${recordingId}`
    ] as const;
    }

    
export const getGetRecordingQueryOptions = <TData = Awaited<ReturnType<typeof getRecording>>, TError = ErrorType<void>>(recordingId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecording>>, TError, TData>>, request?: SecondParameter<typeof axios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecordingQueryKey(recordingId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecording>>> = ({ signal }) => getRecording(recordingId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(recordingId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecording>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecordingQueryResult = NonNullable<Awaited<ReturnType<typeof getRecording>>>
export type GetRecordingQueryError = ErrorType<void>


export function useGetRecording<TData = Awaited<ReturnType<typeof getRecording>>, TError = ErrorType<void>>(
 recordingId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecording>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecording>>,
          TError,
          Awaited<ReturnType<typeof getRecording>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecording<TData = Awaited<ReturnType<typeof getRecording>>, TError = ErrorType<void>>(
 recordingId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecording>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecording>>,
          TError,
          Awaited<ReturnType<typeof getRecording>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecording<TData = Awaited<ReturnType<typeof getRecording>>, TError = ErrorType<void>>(
 recordingId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecording>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRecording<TData = Awaited<ReturnType<typeof getRecording>>, TError = ErrorType<void>>(
 recordingId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecording>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecordingQueryOptions(recordingId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete a recording
 */
export const deleteRecording = (
    recordingId: string,
 options?: SecondParameter<typeof axios>,) => {
      
      
      return axios<void>(
      {url: `/v1/recordings/${recordingId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteRecordingMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRecording>>, TError,{recordingId: string}, TContext>, request?: SecondParameter<typeof axios>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRecording>>, TError,{recordingId: string}, TContext> => {

const mutationKey = ['deleteRecording'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRecording>>, {recordingId: string}> = (props) => {
          const {recordingId} = props ?? {};

          return  deleteRecording(recordingId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRecordingMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRecording>>>
    
    export type DeleteRecordingMutationError = ErrorType<void>

    export const useDeleteRecording = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRecording>>, TError,{recordingId: string}, TContext>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRecording>>,
        TError,
        {recordingId: string},
        TContext
      > => {

      const mutationOptions = getDeleteRecordingMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get or create a chat thread for the current user.
If recordingId is provided, the thread is scoped to that recording.
If not provided, the thread is scoped to all recordings.
 */
export const getOrCreateThread = (
    getOrCreateThreadRequest: GetOrCreateThreadRequest,
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      
      return axios<GetOrCreateThreadResponse>(
      {url: `/v1/chat/threads`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: getOrCreateThreadRequest, signal
    },
      options);
    }
  


export const getGetOrCreateThreadMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getOrCreateThread>>, TError,{data: GetOrCreateThreadRequest}, TContext>, request?: SecondParameter<typeof axios>}
): UseMutationOptions<Awaited<ReturnType<typeof getOrCreateThread>>, TError,{data: GetOrCreateThreadRequest}, TContext> => {

const mutationKey = ['getOrCreateThread'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getOrCreateThread>>, {data: GetOrCreateThreadRequest}> = (props) => {
          const {data} = props ?? {};

          return  getOrCreateThread(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetOrCreateThreadMutationResult = NonNullable<Awaited<ReturnType<typeof getOrCreateThread>>>
    export type GetOrCreateThreadMutationBody = GetOrCreateThreadRequest
    export type GetOrCreateThreadMutationError = ErrorType<void>

    export const useGetOrCreateThread = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getOrCreateThread>>, TError,{data: GetOrCreateThreadRequest}, TContext>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getOrCreateThread>>,
        TError,
        {data: GetOrCreateThreadRequest},
        TContext
      > => {

      const mutationOptions = getGetOrCreateThreadMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get a specific thread by ID.
 */
export const getThread = (
    threadId: string,
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      
      return axios<ChatThread>(
      {url: `/v1/chat/threads/${threadId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetThreadQueryKey = (threadId?: string,) => {
    return [
    `/v1/chat/threads/${threadId}`
    ] as const;
    }

    
export const getGetThreadQueryOptions = <TData = Awaited<ReturnType<typeof getThread>>, TError = ErrorType<void>>(threadId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThread>>, TError, TData>>, request?: SecondParameter<typeof axios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetThreadQueryKey(threadId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getThread>>> = ({ signal }) => getThread(threadId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(threadId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getThread>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetThreadQueryResult = NonNullable<Awaited<ReturnType<typeof getThread>>>
export type GetThreadQueryError = ErrorType<void>


export function useGetThread<TData = Awaited<ReturnType<typeof getThread>>, TError = ErrorType<void>>(
 threadId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThread>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getThread>>,
          TError,
          Awaited<ReturnType<typeof getThread>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetThread<TData = Awaited<ReturnType<typeof getThread>>, TError = ErrorType<void>>(
 threadId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThread>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getThread>>,
          TError,
          Awaited<ReturnType<typeof getThread>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetThread<TData = Awaited<ReturnType<typeof getThread>>, TError = ErrorType<void>>(
 threadId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThread>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetThread<TData = Awaited<ReturnType<typeof getThread>>, TError = ErrorType<void>>(
 threadId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThread>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetThreadQueryOptions(threadId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete a chat thread.
This performs a soft delete.
 */
export const deleteThread = (
    threadId: string,
 options?: SecondParameter<typeof axios>,) => {
      
      
      return axios<void>(
      {url: `/v1/chat/threads/${threadId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteThreadMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteThread>>, TError,{threadId: string}, TContext>, request?: SecondParameter<typeof axios>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteThread>>, TError,{threadId: string}, TContext> => {

const mutationKey = ['deleteThread'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteThread>>, {threadId: string}> = (props) => {
          const {threadId} = props ?? {};

          return  deleteThread(threadId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteThreadMutationResult = NonNullable<Awaited<ReturnType<typeof deleteThread>>>
    
    export type DeleteThreadMutationError = ErrorType<void>

    export const useDeleteThread = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteThread>>, TError,{threadId: string}, TContext>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteThread>>,
        TError,
        {threadId: string},
        TContext
      > => {

      const mutationOptions = getDeleteThreadMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get messages for a thread.
Returns messages ordered by creation time (oldest first).
 */
export const getMessages = (
    threadId: string,
    params?: GetMessagesParams,
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      
      return axios<GetMessagesResponse>(
      {url: `/v1/chat/threads/${threadId}/messages`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetMessagesQueryKey = (threadId?: string,
    params?: GetMessagesParams,) => {
    return [
    `/v1/chat/threads/${threadId}/messages`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetMessagesQueryOptions = <TData = Awaited<ReturnType<typeof getMessages>>, TError = ErrorType<void>>(threadId: string,
    params?: GetMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>>, request?: SecondParameter<typeof axios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMessagesQueryKey(threadId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMessages>>> = ({ signal }) => getMessages(threadId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(threadId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMessagesQueryResult = NonNullable<Awaited<ReturnType<typeof getMessages>>>
export type GetMessagesQueryError = ErrorType<void>


export function useGetMessages<TData = Awaited<ReturnType<typeof getMessages>>, TError = ErrorType<void>>(
 threadId: string,
    params: undefined |  GetMessagesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessages>>,
          TError,
          Awaited<ReturnType<typeof getMessages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessages<TData = Awaited<ReturnType<typeof getMessages>>, TError = ErrorType<void>>(
 threadId: string,
    params?: GetMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessages>>,
          TError,
          Awaited<ReturnType<typeof getMessages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessages<TData = Awaited<ReturnType<typeof getMessages>>, TError = ErrorType<void>>(
 threadId: string,
    params?: GetMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetMessages<TData = Awaited<ReturnType<typeof getMessages>>, TError = ErrorType<void>>(
 threadId: string,
    params?: GetMessagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMessagesQueryOptions(threadId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Send a message to a thread and receive an AI response.
Both the user message and assistant response are stored.
 */
export const sendMessage = (
    threadId: string,
    sendMessageRequest: SendMessageRequest,
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      
      return axios<SendMessageResponse>(
      {url: `/v1/chat/threads/${threadId}/messages`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sendMessageRequest, signal
    },
      options);
    }
  


export const getSendMessageMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendMessage>>, TError,{threadId: string;data: SendMessageRequest}, TContext>, request?: SecondParameter<typeof axios>}
): UseMutationOptions<Awaited<ReturnType<typeof sendMessage>>, TError,{threadId: string;data: SendMessageRequest}, TContext> => {

const mutationKey = ['sendMessage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendMessage>>, {threadId: string;data: SendMessageRequest}> = (props) => {
          const {threadId,data} = props ?? {};

          return  sendMessage(threadId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendMessageMutationResult = NonNullable<Awaited<ReturnType<typeof sendMessage>>>
    export type SendMessageMutationBody = SendMessageRequest
    export type SendMessageMutationError = ErrorType<void>

    export const useSendMessage = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendMessage>>, TError,{threadId: string;data: SendMessageRequest}, TContext>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendMessage>>,
        TError,
        {threadId: string;data: SendMessageRequest},
        TContext
      > => {

      const mutationOptions = getSendMessageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List all available agents/assistants.
 */
export const listAgents = (
    
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      
      return axios<Assistant[]>(
      {url: `/v1/agents`, method: 'GET', signal
    },
      options);
    }
  



export const getListAgentsQueryKey = () => {
    return [
    `/v1/agents`
    ] as const;
    }

    
export const getListAgentsQueryOptions = <TData = Awaited<ReturnType<typeof listAgents>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAgents>>, TError, TData>>, request?: SecondParameter<typeof axios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAgentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAgents>>> = ({ signal }) => listAgents(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAgents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAgentsQueryResult = NonNullable<Awaited<ReturnType<typeof listAgents>>>
export type ListAgentsQueryError = ErrorType<void>


export function useListAgents<TData = Awaited<ReturnType<typeof listAgents>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAgents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAgents>>,
          TError,
          Awaited<ReturnType<typeof listAgents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAgents<TData = Awaited<ReturnType<typeof listAgents>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAgents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAgents>>,
          TError,
          Awaited<ReturnType<typeof listAgents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAgents<TData = Awaited<ReturnType<typeof listAgents>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAgents>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListAgents<TData = Awaited<ReturnType<typeof listAgents>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAgents>>, TError, TData>>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListAgentsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Run an agent with a message.
Optionally provide a threadId to continue an existing conversation.
 */
export const chat = (
    runAgentRequest: RunAgentRequest,
 options?: SecondParameter<typeof axios>,signal?: AbortSignal
) => {
      
      
      return axios<RunAgentResponse>(
      {url: `/v1/agents/chat`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: runAgentRequest, signal
    },
      options);
    }
  


export const getChatMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chat>>, TError,{data: RunAgentRequest}, TContext>, request?: SecondParameter<typeof axios>}
): UseMutationOptions<Awaited<ReturnType<typeof chat>>, TError,{data: RunAgentRequest}, TContext> => {

const mutationKey = ['chat'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chat>>, {data: RunAgentRequest}> = (props) => {
          const {data} = props ?? {};

          return  chat(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChatMutationResult = NonNullable<Awaited<ReturnType<typeof chat>>>
    export type ChatMutationBody = RunAgentRequest
    export type ChatMutationError = ErrorType<void>

    export const useChat = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chat>>, TError,{data: RunAgentRequest}, TContext>, request?: SecondParameter<typeof axios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof chat>>,
        TError,
        {data: RunAgentRequest},
        TContext
      > => {

      const mutationOptions = getChatMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
